Running and Plotting Estimated Effective Migration Surfaces (EEMS)
================

Setup
-----

Install EEMS on your computer following [the instructions](https://github.com/dipetkov/eems). You'll also need to install the R package **rEEMSplots** from source. Using the manual, you'll have to run the MCMC a few times to ensure good mixing. The parameters in the included input file worked well enough for my dataset. For this to work, you'll need a paramter file (params.ini) with your parameters, but no --nDemes flag. You'll also need a datapath.coord, datapath.diffs and a datapath.outer file as described in the manual, located in a folder called input.

Example input and output files are in the **eems_tutorial_files/demes_folder** folder.

Run EEMS for Each Deme Three Times Each (3 Runs)
------------------------------------------------

According to the manual, it is recommended that you use about twice the number of individuals as your number of demes. I ran a range of demes from 20 to 100. Change demes to include the demes that work for your dataset. This will loop EEMS three times for each deme, creating a new folder for each output (/deme20\_run1, /deme20\_run2 etc.). To make creating the average plot easier, I stored all of these deme folders in another folder called deme\_folder.

``` r
demes <- c(20, 40, 60, 80, 100)
for (j in 1:3) {
    for (i in demes) {
        system(paste("./eems/runeems_snps/src/runeems_snps --param params.ini --mcmcpath /demes_", 
            i, "_run", j, " --nDemes ", i, sep = ""))
    }
}
```

Use R to Plot the EEMS Results
------------------------------

Here I'll plot the results of one run: the second run using 60 demes.

``` r
require("rEEMSplots")
library(dplyr)

setwd("/demes_60_run2/")
eems.results.to.plot <- paste(getwd())
names.figures.to.save <- "60_demes_plots"

eems.plots(mcmcpath = eems.results.to.plot, plotpath = names.figures.to.save, longlat = FALSE, 
    out.png = FALSE, add.grid = T, add.demes = T)
```

You can also plot the average of multiple plots, and add the lat long locations of each sampled individual (instead of the deme circles) to the plot. This is where storing all of your deme folders in one folder comes in handy.

First, to add the locations of the individuals, store the lat longs and the colors for each individual. Then, create the average plot.

``` r
setwd("~/Documents/Berkeley/VoleProject/bestrad2016/Analysis/aligned_radtools_noclones/k90_outputs/EEMS/final_filter_corrected21GPS/")
coords <- read.table("input/datapath.coord")
coord_long <- coords$V2
coord_lat <- coords$V1
colors <- c(rep("gray56", 3), rep("black", 2), rep("gray56", 8), rep("gray56", 4), 
    rep("black", 7), rep("black", 4), rep("black", 3))

require("rEEMSplots")
library(dplyr)

setwd("~/Documents/Berkeley/VoleProject/bestrad2016/Analysis/aligned_radtools_noclones/k90_outputs/EEMS/final_filter_corrected21GPS/deme_folders/")
all.the.outputs <- list.dirs(getwd(), recursive = F)
names <- "averaged_over_3runs_20to100demes"
eems.plots(mcmcpath = all.the.outputs, plotpath = names, longlat = FALSE, out.png = FALSE, 
    m.plot.xy = {
        points(coord_long, coord_lat, pch = 20, cex = 1.2, col = colors)
    }, q.plot.xy = {
        points(coord_long, coord_lat, pch = 2, cex = 1.2, col = colors)
    })
```

Customize the Isolation By Distance Plots that EEMS Already Makes
-----------------------------------------------------------------

EEMS automatically outputs a crude IBD plot. You can access the inner data generated by EEMS to customize that plot.

From the output of the second run of the 60 deeme run, you can customize the IBD plot. You can also run a Shapiro test to test for normality of the observed demes, and then see if genetic distance increases linearly with distance.

``` r
load("deme_folders/demes_60_run2/60_demes_IBDplot-rdist.RData")


plot(G.component$obsrvd ~ G.component$fitted, xlab = "Distance Between Demes (km)", 
    ylab = "Observed Genetic Dissimilarity Between Demes", pch = 20, cex = 1.5, cex.lab = 1.2, 
    cex.axis = 1.2)
abline(lm(G.component$obsrvd ~ G.component$fitted), lwd = 2)

shapiro.test(G.component$obsrvd)
summary(lm(G.component$obsrvd ~ G.component$fitted))
```
